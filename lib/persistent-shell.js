// Generated by CoffeeScript 1.12.7
(function() {
  var EventEmitter, SSH2Shell, typeIsArray,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  EventEmitter = require('events').EventEmitter;

  SSH2Shell = (function(superClass) {
    extend(SSH2Shell, superClass);

    SSH2Shell.prototype.host = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype._firstPrompt = true;

    SSH2Shell.prototype.asciiFilter = "";

    SSH2Shell.prototype.textColorFilter = "";

    SSH2Shell.prototype.onEnd = function() {};

    SSH2Shell.prototype.pipe = function(destination) {
      this._pipes.push(destination);
      return this;
    };

    SSH2Shell.prototype.unpipe = function() {};

    SSH2Shell.prototype._processData = function(data) {
      if (!this.host.disableColorFilter) {
        if (this.host.verbose) {
          this.emit('info', (this.host.server.host + ": text formatting filter:") + this.host.textColorFilter + ", response is ok: " + this.textColorFilter.test(data));
        }
        data = data.replace(this.textColorFilter, "");
      }
      if (!this.host.disableASCIIFilter) {
        if (this.host.verbose) {
          this.emit('info', (this.host.server.host + ": ASCII filter: ") + this.host.asciiFilter + ", response is ok:" + this.asciiFilter.test(data));
        }
        data = data.replace(this.asciiFilter, "");
      }
      this.emit('msg', data);
      this._buffer += data;
      if (!this._firstPrompt && this.standardPromt.test(this._buffer.replace(this.command.substr(0, this._buffer.length), ""))) {
        if (this.host.debug) {
          this.emit('info', this.host.server.host + ": Normal prompt detected");
        }
        return this._commandComplete();
      } else if (this._firstPrompt && this.standardPromt.test(this._buffer)) {
        if (this.host.debug) {
          this.emit('info', this.host.server.host + ": First prompt detected");
        }
        this._firstPrompt = false;
        if (this.host.showBanner) {
          this.host.sessionText += this._buffer;
        }
        return this._buffer = "";
      }
    };

    SSH2Shell.prototype._commandComplete = function() {
      var response;
      response = this._buffer.replace(this.command, "");
      if (this.host.verbose) {
        this.emit('info', this.host.server.host + ": Command complete:\nCommand:\n " + this.command + "\nResponse: " + response);
      }
      this.host.sessionText += response;
      this._buffer = "";
      if (this.host.debug) {
        this.emit('info', this.host.server.host + ": Raising commandComplete event");
      }
      this.emit('commandComplete', this.command, response);
      if (typeIsArray(this.host.commands) && this.host.commands.length > 0) {
        return this._nextCommand();
      }
    };

    SSH2Shell.prototype._nextCommand = function() {
      var command;
      if (this.host.verbose) {
        this.emit('msg', this.host.server.host + ": Host.commands: " + this.host.commands);
      }
      if (this.host.verbose) {
        this.emit('msg', this.host.server.host + ": Next command from host.commands: " + this.command);
      }
      command = this.host.commands.shift();
      return this.runCommand(command);
    };

    SSH2Shell.prototype.runCommand = function(command1) {
      this.command = command1;
      if (this.host.verbose) {
        this.emit('info', this.host.server.host + ": running: " + this.command);
      }
      this._stream.write("" + this.command + this.host.enter);
      if (this.command === "exit") {
        return this.exit();
      }
    };

    SSH2Shell.prototype.exit = function() {
      if (this.host.debug) {
        this.emit('info', this.host.server.host + ": Exit command: Stream: close");
      }
      return this._stream.close();
    };

    SSH2Shell.prototype._loadDefaults = function() {
      var ref, ref1, ref2;
      if (!this.host.commands) {
        this.host.commands = [];
      }
      if (!this.host.connectedMessage) {
        this.host.connectedMessage = "Connected";
      }
      if (!this.host.readyMessage) {
        this.host.readyMessage = "Ready";
      }
      if (!this.host.closedMessage) {
        this.host.closedMessage = "Closed";
      }
      if (!this.host.showBanner) {
        this.host.showBanner = false;
      }
      if (!this.host.verbose) {
        this.host.verbose = false;
      }
      if (!this.host.debug) {
        this.host.debug = false;
      }
      if (!this.host.standardPrompt) {
        this.host.standardPrompt = ">$%#";
      }
      if (!this.host.enter) {
        this.host.enter = "\n";
      }
      if (!this.host.asciiFilter) {
        this.host.asciiFilter = "[^\r\n\x20-\x7e]";
      }
      if (this.host.disableColorFilter !== true) {
        this.host.disableColorFilter = false;
      }
      if (this.host.disableASCIIFilter !== true) {
        this.host.disableASCIIFilter = false;
      }
      if (!this.host.textColorFilter) {
        this.host.textColorFilter = "(\[{1}[0-9;]+m{1})";
      }
      if (!this.host.sessionText) {
        this.host.sessionText = "";
      }
      this.host.streamEncoding = (ref = this.host.streamEncoding) != null ? ref : "utf8";
      if (!this.host.window) {
        this.host.window = true;
      }
      if (!this.host.pty) {
        this.host.pty = true;
      }
      if (!this.asciiFilter) {
        this.asciiFilter = new RegExp(this.host.asciiFilter, "g");
      }
      if (!this.textColorFilter) {
        this.textColorFilter = new RegExp(this.host.textColorFilter, "g");
      }
      if (!this.standardPromt) {
        this.standardPromt = new RegExp("[" + this.host.standardPrompt + "]\\s?$");
      }
      if (this.host.callback) {
        this._callback = this.host.callback;
      }
      this._pipes = [];
      this.onCommandComplete = (ref1 = this.host.onCommandComplete) != null ? ref1 : (function(_this) {
        return function(command, response) {
          if (_this.host.debug) {
            return _this.emit('info', _this.host.server.host + ": Class commandComplete");
          }
        };
      })(this);
      this.onEnd = (ref2 = this.host.onEnd) != null ? ref2 : (function(_this) {
        return function(sessionText) {
          if (_this.host.debug) {
            return _this.emit('info', _this.host.server.host + ": Class.end");
          }
        };
      })(this);
      this.on("commandComplete", this.onCommandComplete);
      return this.on("end", this.onEnd);
    };

    function SSH2Shell(host) {
      this._connect = bind(this._connect, this);
      this.connect = bind(this.connect, this);
      this._initiate = bind(this._initiate, this);
      this._loadDefaults = bind(this._loadDefaults, this);
      this.exit = bind(this.exit, this);
      this.runCommand = bind(this.runCommand, this);
      this._nextCommand = bind(this._nextCommand, this);
      this._commandComplete = bind(this._commandComplete, this);
      this._processData = bind(this._processData, this);
      this.unpipe = bind(this.unpipe, this);
      this.pipe = bind(this.pipe, this);
      this.onEnd = bind(this.onEnd, this);
      this.host = host;
      this.connection = new require('ssh2')();
    }

    SSH2Shell.prototype._initiate = function() {
      var ref, ref1, ref2, ref3, ref4, ref5, ref6;
      if (this.host.debug) {
        this.emit('info', this.host.server.host + ": initiate");
      }
      this._loadDefaults();
      this.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          var str;
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Class.keyboard-interactive");
          }
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Keyboard-interactive: finish([response, array]) not called in class event handler.");
          }
          if (_this.host.verbose) {
            _this.emit('info', "name: " + name);
            _this.emit('info', "instructions: " + instructions);
            str = JSON.stringify(prompts, null, 4);
            return _this.emit('info', "Prompts object: " + str);
          }
        };
      })(this));
      if (this.host.onKeyboardInteractive) {
        this.host.onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish);
      }
      this.on("msg", (ref = this.host.msg) != null ? ref : (function(_this) {
        return function(message) {
          return process.stdout.write(message);
        };
      })(this));
      this.on("info", (ref1 = this.host.info) != null ? ref1 : (function(_this) {
        return function(message) {
          return process.stdout.write(message + _this.host.enter);
        };
      })(this));
      this.on("error", (ref2 = this.host.onError) != null ? ref2 : (function(_this) {
        return function(err, type, close, callback) {
          if (close == null) {
            close = false;
          }
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Class.error");
          }
          if (err instanceof Error) {
            return _this.emit('info', "Error: " + err.message + ", Level: " + err.level);
          } else {
            _this.emit('info', (type + " error: ") + err);
            if (callback) {
              callback(err, type);
            }
            if (close) {
              return _this.connection.end();
            }
          }
        };
      })(this));
      this.on("pipe", (ref3 = this.host.onPipe) != null ? ref3 : (function(_this) {
        return function(source) {
          if (_this.host.debug) {
            return _this.emit('info', _this.host.server.host + ": Class.pipe");
          }
        };
      })(this));
      this.on("unpipe", (ref4 = this.host.onUnpipe) != null ? ref4 : (function(_this) {
        return function(source) {
          if (_this.host.debug) {
            return _this.emit('info', _this.host.server.host + ": Class.unpipe");
          }
        };
      })(this));
      this.on("data", (ref5 = this.host.onData) != null ? ref5 : (function(_this) {
        return function(data) {
          if (_this.host.debug) {
            return _this.emit('info', _this.host.server.host + ": data event");
          }
        };
      })(this));
      return this.on("stderrData", (ref6 = this.host.onStderrData) != null ? ref6 : (function(_this) {
        return function(data) {
          return console.error(data);
        };
      })(this));
    };

    SSH2Shell.prototype.connect = function(callback) {
      if (callback) {
        this._callback = callback;
      }
      this._initiate();
      return this._connect();
    };

    SSH2Shell.prototype._connect = function() {
      var e;
      this.connection.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Connection.keyboard-interactive");
          }
          return _this.emit("keyboard-interactive", name, instructions, instructionsLang, prompts, finish);
        };
      })(this));
      this.connection.on("connect", (function(_this) {
        return function() {
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Connection.connect");
          }
          return _this.emit('info', _this.host.connectedMessage);
        };
      })(this));
      this.connection.on("ready", (function(_this) {
        return function() {
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Connection.ready");
          }
          _this.emit('info', _this.host.readyMessage);
          return _this.connection.shell(_this.host.window, {
            pty: _this.host.pty
          }, function(err, _stream) {
            var i, len, pipe, ref;
            _this._stream = _stream;
            if (err) {
              _this.emit('error', err, "Shell", true);
            }
            if (_this.host.debug) {
              _this.emit('info', _this.host.server.host + ": Connection.shell");
            }
            _this.host.sessionText = "Connected to " + _this.host.server.host + _this.host.enter;
            _this._stream.setEncoding(_this.host.streamEncoding);
            ref = _this._pipes;
            for (i = 0, len = ref.length; i < len; i++) {
              pipe = ref[i];
              _this._stream.pipe(pipe);
            }
            _this.unpipe = _this._stream.unpipe;
            _this._stream.on("error", function(err) {
              if (_this.host.debug) {
                _this.emit('info', _this.host.server.host + ": Stream.error");
              }
              return _this.emit('error', err, "Stream");
            });
            _this._stream.stderr.on('data', function(data) {
              if (_this.host.debug) {
                _this.emit('info', _this.host.server.host + ": Stream.stderr.data");
              }
              return _this.emit('stderrData', data);
            });
            _this._stream.on("data", function(data) {
              var e;
              try {
                _this.emit('data', data);
                return _this._processData(data);
              } catch (error) {
                e = error;
                err = new Error(e + " " + e.stack);
                err.level = "Data handling";
                return _this.emit('error', err, "Stream.read", true);
              }
            });
            _this._stream.on("pipe", function(source) {
              return _this.emit('pipe', source);
            });
            _this._stream.on("unpipe", function(source) {
              return _this.emit('unpipe', source);
            });
            _this._stream.on("finish", function() {
              if (_this.host.debug) {
                _this.emit('info', _this.host.server.host + ": Stream.finish");
              }
              _this.emit('end', _this.host.sessionText, _this.host);
              if (_this._callback) {
                return _this._callback(_this.host.sessionText);
              }
            });
            return _this._stream.on("close", function(code, signal) {
              if (_this.host.debug) {
                _this.emit('info', _this.host.server.host + ": Stream.close");
              }
              return _this.connection.end();
            });
          });
        };
      })(this));
      this.connection.on("error", (function(_this) {
        return function(err) {
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Connection.error");
          }
          return _this.emit("error", err, "Connection");
        };
      })(this));
      this.connection.on("close", (function(_this) {
        return function(had_error) {
          if (_this.host.debug) {
            _this.emit('info', _this.host.server.host + ": Connection.close");
          }
          if (had_error) {
            return _this.emit("error", had_error, "Connection close");
          } else {
            return _this.emit('info', _this.host.closedMessage);
          }
        };
      })(this));
      if (this.host.server) {
        try {
          this.connection.connect({
            host: this.host.server.host,
            port: this.host.server.port,
            forceIPv4: this.host.server.forceIPv4,
            forceIPv6: this.host.server.forceIPv6,
            hostHash: this.host.server.hashMethod,
            hostVerifier: this.host.server.hostVerifier,
            username: this.host.server.userName,
            password: this.host.server.password,
            agent: this.host.server.agent,
            agentForward: this.host.server.agentForward,
            privateKey: this.host.server.privateKey,
            passphrase: this.host.server.passPhrase,
            localHostname: this.host.server.localHostname,
            localUsername: this.host.server.localUsername,
            tryKeyboard: this.host.server.tryKeyboard,
            keepaliveInterval: this.host.server.keepaliveInterval,
            keepaliveCountMax: this.host.server.keepaliveCountMax,
            readyTimeout: this.host.server.readyTimeout,
            sock: this.host.server.sock,
            strictVendor: this.host.server.strictVendor,
            algorithms: this.host.server.algorithms,
            compress: this.host.server.compress,
            debug: this.host.server.debug
          });
        } catch (error) {
          e = error;
          this.emit('error', e + " " + e.stack, "Connection.connect", true);
        }
      } else {
        this.emit('error', "Missing connection parameters", "Parameters", false, function(err, type, close) {
          return this.emit('info', this.host.server);
        });
      }
      return this._stream;
    };

    return SSH2Shell;

  })(EventEmitter);

  module.exports = SSH2Shell;

}).call(this);
