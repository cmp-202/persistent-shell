// Generated by CoffeeScript 1.12.7
(function() {
  var EventEmitter, SSH2Shell, typeIsArray,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  EventEmitter = require('events').EventEmitter;

  SSH2Shell = (function(superClass) {
    extend(SSH2Shell, superClass);

    SSH2Shell.prototype.sshObj = {};

    SSH2Shell.prototype.command = "";

    SSH2Shell.prototype._stream = {};

    SSH2Shell.prototype._data = "";

    SSH2Shell.prototype._buffer = "";

    SSH2Shell.prototype.asciiFilter = "";

    SSH2Shell.prototype.textColorFilter = "";

    SSH2Shell.prototype.stdin = process.openStdin();

    SSH2Shell.prototype.onEnd = function() {};

    SSH2Shell.prototype.pipe = function(destination) {
      this._pipes.push(destination);
      return this;
    };

    SSH2Shell.prototype.unpipe = function() {};

    SSH2Shell.prototype._processData = function(data) {
      this._buffer += data;
      if (!this.sshObj.disableColorFilter) {
        if (this.sshObj.verbose) {
          this.emit('msg', (this.sshObj.server.host + ": text formatting filter:") + this.sshObj.textColorFilter + ", response is ok: " + this.textColorFilter.test(this._buffer));
        }
        this._buffer = this._buffer.replace(this.textColorFilter, "");
      }
      if (!this.sshObj.disableASCIIFilter) {
        if (this.sshObj.verbose) {
          this.emit('msg', (this.sshObj.server.host + ": ASCII filter: ") + this.sshObj.asciiFilter + ", response is ok:" + this.asciiFilter.test(this._buffer));
        }
        this._buffer = this._buffer.replace(this.asciiFilter, "");
      }
      if (this.command.length > 0 && this.standardPromt.test(this._buffer.replace(this.command.substr(0, this._buffer.length), ""))) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": Normal prompt detected");
        }
        return this._commandComplete();
      } else if (this.command.length < 1 && this.standardPromt.test(this._buffer)) {
        if (this.sshObj.debug) {
          this.emit('msg', this.sshObj.server.host + ": First prompt detected");
        }
        if (this.sshObj.showBanner) {
          process.stdout.write(this._buffer);
          this.sshObj.sessionText += this._buffer;
          return this._buffer = "";
        } else {
          return this._buffer = "";
        }
      }
    };

    SSH2Shell.prototype._commandComplete = function() {
      var response;
      response = this._buffer.replace(this.command, "");
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": Command complete:\nCommand:\n " + this.command + "\nResponse: " + response);
      }
      this.emit('msg', response);
      this.sshObj.sessionText += response;
      this._buffer = "";
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Raising commandComplete event");
      }
      return this.emit('commandComplete', this.command, response);
    };

    SSH2Shell.prototype.runCommand = function(command) {
      this.command = command;
      if (this.sshObj.verbose) {
        this.emit('msg', this.sshObj.server.host + ": running: " + this.command);
      }
      this._stream.write("" + this.command + this.sshObj.enter);
      if (this.command === "exit") {
        return this.exit();
      }
    };

    SSH2Shell.prototype.exit = function() {
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": Exit command: Stream: close");
      }
      this.stdin.end();
      return this._stream.close();
    };

    SSH2Shell.prototype._loadDefaults = function() {
      var ref, ref1, ref2;
      if (!this.sshObj.msg) {
        this.sshObj.msg = {
          send: (function(_this) {
            return function(message) {
              return process.stdout.write(message);
            };
          })(this)
        };
      }
      if (!this.sshObj.connectedMessage) {
        this.sshObj.connectedMessage = "Connected";
      }
      if (!this.sshObj.readyMessage) {
        this.sshObj.readyMessage = "Ready";
      }
      if (!this.sshObj.closedMessage) {
        this.sshObj.closedMessage = "Closed";
      }
      if (!this.sshObj.showBanner) {
        this.sshObj.showBanner = false;
      }
      if (!this.sshObj.verbose) {
        this.sshObj.verbose = false;
      }
      if (!this.sshObj.debug) {
        this.sshObj.debug = false;
      }
      if (!this.sshObj.standardPrompt) {
        this.sshObj.standardPrompt = ">$%#";
      }
      if (!this.sshObj.enter) {
        this.sshObj.enter = "\n";
      }
      if (!this.sshObj.asciiFilter) {
        this.sshObj.asciiFilter = "[^\r\n\x20-\x7e]";
      }
      if (this.sshObj.disableColorFilter !== true) {
        this.sshObj.disableColorFilter = false;
      }
      if (this.sshObj.disableASCIIFilter !== true) {
        this.sshObj.disableASCIIFilter = false;
      }
      if (!this.sshObj.textColorFilter) {
        this.sshObj.textColorFilter = "(\[{1}[0-9;]+m{1})";
      }
      if (!this.sshObj.sessionText) {
        this.sshObj.sessionText = "";
      }
      this.sshObj.streamEncoding = (ref = this.sshObj.streamEncoding) != null ? ref : "utf8";
      if (!this.sshObj.window) {
        this.sshObj.window = true;
      }
      if (!this.sshObj.pty) {
        this.sshObj.pty = true;
      }
      if (!this.asciiFilter) {
        this.asciiFilter = new RegExp(this.sshObj.asciiFilter, "g");
      }
      if (!this.textColorFilter) {
        this.textColorFilter = new RegExp(this.sshObj.textColorFilter, "g");
      }
      if (!this.standardPromt) {
        this.standardPromt = new RegExp("[" + this.sshObj.standardPrompt + "]\\s?$");
      }
      if (this.sshObj.callback) {
        this._callback = this.sshObj.callback;
      }
      this._pipes = [];
      this.onCommandComplete = (ref1 = this.sshObj.onCommandComplete) != null ? ref1 : (function(_this) {
        return function(response) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": ClasscommandComplete");
          }
        };
      })(this);
      this.onEnd = (ref2 = this.sshObj.onEnd) != null ? ref2 : (function(_this) {
        return function(sessionText, sshObj) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.end");
          }
        };
      })(this);
      this.on("commandComplete", this.onCommandComplete);
      return this.on("end", this.onEnd);
    };

    function SSH2Shell(host) {
      this._connect = bind(this._connect, this);
      this.connect = bind(this.connect, this);
      this._initiate = bind(this._initiate, this);
      this._loadDefaults = bind(this._loadDefaults, this);
      this.exit = bind(this.exit, this);
      this.runCommand = bind(this.runCommand, this);
      this._commandComplete = bind(this._commandComplete, this);
      this._processData = bind(this._processData, this);
      this.unpipe = bind(this.unpipe, this);
      this.pipe = bind(this.pipe, this);
      this.onEnd = bind(this.onEnd, this);
      this.sshObj = host;
      this.connection = new require('ssh2')();
    }

    SSH2Shell.prototype._initiate = function() {
      var ref, ref1, ref2, ref3, ref4, ref5;
      if (this.sshObj.debug) {
        this.emit('msg', this.sshObj.server.host + ": initiate");
      }
      this._loadDefaults();
      this.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          var str;
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.keyboard-interactive");
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Keyboard-interactive: finish([response, array]) not called in class event handler.");
          }
          if (_this.sshObj.verbose) {
            _this.emit('msg', "name: " + name);
            _this.emit('msg', "instructions: " + instructions);
            str = JSON.stringify(prompts, null, 4);
            return _this.emit('msg', "Prompts object: " + str);
          }
        };
      })(this));
      if (this.sshObj.onKeyboardInteractive) {
        this.sshObj.onKeyboardInteractive(name, instructions, instructionsLang, prompts, finish);
      }
      this.on("msg", (ref = this.sshObj.msg.send) != null ? ref : (function(_this) {
        return function(message) {
          return console.log(message);
        };
      })(this));
      this.on("error", (ref1 = this.sshObj.onError) != null ? ref1 : (function(_this) {
        return function(err, type, close, callback) {
          if (close == null) {
            close = false;
          }
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Class.error");
          }
          if (err instanceof Error) {
            return _this.emit('msg', "Error: " + err.message + ", Level: " + err.level);
          } else {
            _this.emit('msg', (type + " error: ") + err);
            if (callback) {
              callback(err, type);
            }
            if (close) {
              _this.connection.end();
              return _this.stdin.end();
            }
          }
        };
      })(this));
      this.on("pipe", (ref2 = this.sshObj.onPipe) != null ? ref2 : (function(_this) {
        return function(source) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.pipe");
          }
        };
      })(this));
      this.on("unpipe", (ref3 = this.sshObj.onUnpipe) != null ? ref3 : (function(_this) {
        return function(source) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": Class.unpipe");
          }
        };
      })(this));
      this.on("data", (ref4 = this.sshObj.onData) != null ? ref4 : (function(_this) {
        return function(data) {
          if (_this.sshObj.debug) {
            return _this.emit('msg', _this.sshObj.server.host + ": data event");
          }
        };
      })(this));
      this.on("stderrData", (ref5 = this.sshObj.onStderrData) != null ? ref5 : (function(_this) {
        return function(data) {
          return console.error(data);
        };
      })(this));
      return this.stdin.addListener("data", (function(_this) {
        return function(input) {
          _this.command = input.toString().trim();
          return _this.runCommand(_this.command);
        };
      })(this));
    };

    SSH2Shell.prototype.connect = function(callback) {
      if (callback) {
        this._callback = callback;
      }
      this._initiate();
      return this._connect();
    };

    SSH2Shell.prototype._connect = function() {
      var e;
      this.connection.on("keyboard-interactive", (function(_this) {
        return function(name, instructions, instructionsLang, prompts, finish) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.keyboard-interactive");
          }
          return _this.emit("keyboard-interactive", name, instructions, instructionsLang, prompts, finish);
        };
      })(this));
      this.connection.on("connect", (function(_this) {
        return function() {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.connect");
          }
          return _this.emit('msg', _this.sshObj.connectedMessage);
        };
      })(this));
      this.connection.on("ready", (function(_this) {
        return function() {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.ready");
          }
          _this.emit('msg', _this.sshObj.readyMessage);
          return _this.connection.shell(_this.sshObj.window, {
            pty: _this.sshObj.pty
          }, function(err, _stream) {
            var i, len, pipe, ref;
            _this._stream = _stream;
            if (err) {
              _this.emit('error', err, "Shell", true);
            }
            if (_this.sshObj.debug) {
              _this.emit('msg', _this.sshObj.server.host + ": Connection.shell");
            }
            _this.sshObj.sessionText = "Connected to " + _this.sshObj.server.host + _this.sshObj.enter;
            _this._stream.setEncoding(_this.sshObj.streamEncoding);
            ref = _this._pipes;
            for (i = 0, len = ref.length; i < len; i++) {
              pipe = ref[i];
              _this._stream.pipe(pipe);
            }
            _this.unpipe = _this._stream.unpipe;
            _this._stream.on("error", function(err) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.error");
              }
              return _this.emit('error', err, "Stream");
            });
            _this._stream.stderr.on('data', function(data) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.stderr.data");
              }
              return _this.emit('stderrData', data);
            });
            _this._stream.on("data", function(data) {
              var e;
              try {
                _this.emit('data', data);
                return _this._processData(data);
              } catch (error) {
                e = error;
                err = new Error(e + " " + e.stack);
                err.level = "Data handling";
                return _this.emit('error', err, "Stream.read", true);
              }
            });
            _this._stream.on("pipe", function(source) {
              return _this.emit('pipe', source);
            });
            _this._stream.on("unpipe", function(source) {
              return _this.emit('unpipe', source);
            });
            _this._stream.on("finish", function() {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.finish");
              }
              _this.emit('end', _this.sshObj.sessionText, _this.sshObj);
              if (_this._callback) {
                return _this._callback(_this.sshObj.sessionText);
              }
            });
            return _this._stream.on("close", function(code, signal) {
              if (_this.sshObj.debug) {
                _this.emit('msg', _this.sshObj.server.host + ": Stream.close");
              }
              return _this.connection.end();
            });
          });
        };
      })(this));
      this.connection.on("error", (function(_this) {
        return function(err) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.error");
          }
          return _this.emit("error", err, "Connection");
        };
      })(this));
      this.connection.on("close", (function(_this) {
        return function(had_error) {
          if (_this.sshObj.debug) {
            _this.emit('msg', _this.sshObj.server.host + ": Connection.close");
          }
          if (had_error) {
            return _this.emit("error", had_error, "Connection close");
          } else {
            return _this.emit('msg', _this.sshObj.closedMessage);
          }
        };
      })(this));
      if (this.sshObj.server) {
        try {
          this.connection.connect({
            host: this.sshObj.server.host,
            port: this.sshObj.server.port,
            forceIPv4: this.sshObj.server.forceIPv4,
            forceIPv6: this.sshObj.server.forceIPv6,
            hostHash: this.sshObj.server.hashMethod,
            hostVerifier: this.sshObj.server.hostVerifier,
            username: this.sshObj.server.userName,
            password: this.sshObj.server.password,
            agent: this.sshObj.server.agent,
            agentForward: this.sshObj.server.agentForward,
            privateKey: this.sshObj.server.privateKey,
            passphrase: this.sshObj.server.passPhrase,
            localHostname: this.sshObj.server.localHostname,
            localUsername: this.sshObj.server.localUsername,
            tryKeyboard: this.sshObj.server.tryKeyboard,
            keepaliveInterval: this.sshObj.server.keepaliveInterval,
            keepaliveCountMax: this.sshObj.server.keepaliveCountMax,
            readyTimeout: this.sshObj.server.readyTimeout,
            sock: this.sshObj.server.sock,
            strictVendor: this.sshObj.server.strictVendor,
            algorithms: this.sshObj.server.algorithms,
            compress: this.sshObj.server.compress,
            debug: this.sshObj.server.debug
          });
        } catch (error) {
          e = error;
          this.emit('error', e + " " + e.stack, "Connection.connect", true);
        }
      } else {
        this.emit('error', "Missing connection parameters", "Parameters", false, function(err, type, close) {
          this.removeListener('data', this.onCommandProcessing);
          return this.emit('msg', this.sshObj.server);
        });
      }
      return this._stream;
    };

    return SSH2Shell;

  })(EventEmitter);

  module.exports = SSH2Shell;

}).call(this);
